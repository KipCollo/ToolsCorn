# Docker images

Docker images are lightweight, standalone, and executable packages that include the application and all its dependencies. Images are built from a set of instructions defined in a Dockerfile. They are stored in a registry, such as Docker Hub or a private registry, and can be easily shared and distributed.

A Docker image is a unit of packaging that contains everything required for an application to run. This includes;-application code, application dependencies, and OS constructs. If you have an applicationâ€™s Docker image, the only other thing you need to run that application is a computer running Docker.

You get Docker images by pulling them from an image registry. THe most common registry is Docker Hub, but others exist. The pull operation downloads the image to your local Docker host where Docker can use it to start one or more containers.

Images are made up of multiple layers that are stacked on top of each other and represented as a single object.Inside of the image is a cut-down operating system (OS) and all of the files and dependencies required to run an application. Because containers are intended to be fast and lightweight, images tend to be small (Microsoft images tend to be huge).

Images are categorized into:-

1. Base Image:- Images that have no parent image,usually images with an OS like Ubuntu
2. Child images:- Images that build on base images and add additional functionalities.

There also are:

1. Pre-Built image
2. Custom Image

Images contains multiple layers(1 instruction = 1 layer) to optimize build speed(caching) and re-usability.

## Dockerfile

Docker can build images automatically by reading the instructions from a Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. This page describes the commands you can use in a Dockerfile.

## Anatomy of a Dockerfile

To create a custom Docker image with the default tools, you will need to become familiar with the Dockerfile. This file describes all the steps that are required to create
one image and would usually be contained within the root directory of the source code repository for your application.

Each line in a Dockerfile creates a new image layer that is stored by Docker. This means that when you build new images, Docker will only need to build layers that deviate from previous builds.

The Dockerfile supports the following instructions:

1. FROM - Create a new build stage from a base image.
2. RUN - Execute build commands.
3. MAINTAINER - Specify the author of an image.
4. COPY - Copy files and directories.
5. ADD - Add local or remote files and directories.
6. EXPOSE -Describe which ports your application is listening on.
7. WORKDIR - Change working directory.
8. CMD - Specify default commands.
9. ENTRYPOINTS -Specify default executable.
10. ENV - Set environment variables.
11. VOLUME - Create volume mounts.
12. USER - Set user and group ID.
13. LABEL - Add metadata to an image.
14. ONBUILD - Specify instructions for when the image is used in a build.
15. SHELL - Set the default shell of an image.
16. ARG - Use build-time variables.
17. HEALTHCHECK - Check a container's health on startup.
18. STOPSIGNAL - Specify the system call signal for exiting a container.
19. ARG- Use build-time variables.

`FROM`- The FROM instruction initializes a new build stage and sets the base image for subsequent instructions. As such, a valid Dockerfile must start with a FROM instruction. The image can be any valid image.

```Dockerfile
FROM [--platform=<platform>] <image> [AS <name>]
FROM [--platform=<platform>] <image>[:<tag>] [AS <name>]
FROM [--platform=<platform>] <image>[@<digest>] [AS <name>]
```

- ARG is the only instruction that may precede FROM in the Dockerfile.
- FROM can appear multiple times within a single Dockerfile to create multiple images or use one build stage as a dependency for another. Simply make a note of the last image ID output by the commit before each new FROM instruction. Each FROM instruction clears any state created by previous instructions.
- Optionally a name can be given to a new build stage by adding AS name to the FROM instruction. The name can be used in subsequent FROM <name>, COPY --from=<name>, and RUN --mount=type=bind,from=<name> instructions to refer to the image built in this stage.
- The tag or digest values are optional. If you omit either of them, the builder assumes a latest tag by default. The builder returns an error if it can't find the tag value.

The optional --platform flag can be used to specify the platform of the image in case FROM references a multi-platform image. For example, linux/amd64, linux/arm64, or windows/amd64. By default, the target platform of the build request is used. Global build arguments can be used in the value of this flag, for example automatic platform ARGs allow you to force a stage to native build platform (--platform=$BUILDPLATFORM), and use it to cross-compile to the target platform inside the stage.
Understand how ARG and FROM interact

FROM instructions support variables that are declared by any ARG instructions that occur before the first FROM.

```Dockerfile
ARG  CODE_VERSION=latest
FROM base:${CODE_VERSION}
CMD  /code/run-app

FROM extras:${CODE_VERSION}
CMD  /code/run-extras
```

An ARG declared before a FROM is outside of a build stage, so it can't be used in any instruction after a FROM. To use the default value of an ARG declared before the first FROM use an ARG instruction without a value inside of a build stage:

```Dockerfile
ARG VERSION=latest
FROM busybox:$VERSION
ARG VERSION
RUN echo $VERSION > image_version
```

`WORKDIR`:- The WORKDIR instruction sets the working directory for any RUN, CMD, ENTRYPOINT, COPY and ADD instructions that follow it in the Dockerfile. If the WORKDIR doesn't exist, it will be created even if it's not used in any subsequent Dockerfile instruction.

WORKDIR /path/to/workdir

The WORKDIR instruction can be used multiple times in a Dockerfile. If a relative path is provided, it will be relative to the path of the previous WORKDIR instruction. For example:

```Dockerfile
WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd
```

The output of the final pwd command in this Dockerfile would be /a/b/c.

The WORKDIR instruction can resolve environment variables previously set using ENV. You can only use environment variables explicitly set in the Dockerfile. For example:

```Dockerfile
ENV DIRPATH=/path
WORKDIR $DIRPATH/$DIRNAME
RUN pwd
```

The output of the final pwd command in this Dockerfile would be /path/$DIRNAME

If not specified, the default working directory is /. In practice, if you aren't building a Dockerfile from scratch (FROM scratch), the WORKDIR may likely be set by the base image you're using.

Therefore, to avoid unintended operations in unknown directories, it's best practice to set your WORKDIR explicitly.

**COPY**:-COPY has two forms. The latter form is required for paths containing whitespace.

```Dockerfile
COPY [OPTIONS] <src> ... <dest>
COPY [OPTIONS] ["<src>", ... "<dest>"]
```

The available [OPTIONS] are:

```Dockerfile
--from
--chown
--chmod  1.2
--link 1.4
--parents 1.7-labs
--exclude 1.7-labs
```

The COPY instruction copies new files or directories from *src** and adds them to the filesystem of the image at the path <dest>. Files and directories can be copied from the build context, build stage, named context, or an image.

The ADD and COPY instructions are functionally similar, but serve slightly different purposes. Learn more about the differences between ADD and COPY

.
Source

You can specify multiple source files or directories with COPY. The last argument must always be the destination. For example, to copy two files, file1.txt and file2.txt, from the build context to /usr/src/things/ in the build container:

COPY file1.txt file2.txt /usr/src/things/

If you specify multiple source files, either directly or using a wildcard, then the destination must be a directory (must end with a slash /).

COPY accepts a flag --from=<name> that lets you specify the source location to be a build stage, context, or image. The following example copies files from a stage named build:

FROM golang AS build
WORKDIR /app
RUN --mount=type=bind,target=. go build -o /myapp ./cmd

COPY --from=build /myapp /usr/bin/

For more information about copying from named sources, see the --from flag.
Copying from the build context

When copying source files from the build context, paths are interpreted as relative to the root of the context.

Specifying a source path with a leading slash or one that navigates outside the build context, such as COPY ../something /something, automatically removes any parent directory navigation (../). Trailing slashes in the source path are also disregarded, making COPY something/ /something equivalent to COPY something /something.

If the source is a directory, the contents of the directory are copied, including filesystem metadata. The directory itself isn't copied, only its contents. If it contains subdirectories, these are also copied, and merged with any existing directories at the destination. Any conflicts are resolved in favor of the content being added, on a file-by-file basis, except if you're trying to copy a directory onto an existing file, in which case an error is raised.

If the source is a file, the file and its metadata are copied to the destination. File permissions are preserved. If the source is a file and a directory with the same name exists at the destination, an error is raised.

If you pass a Dockerfile through stdin to the build (docker build - < Dockerfile), there is no build context. In this case, you can only use the COPY instruction to copy files from other stages, named contexts, or images, using the --from flag. You can also pass a tar archive through stdin: (docker build - < archive.tar), the Dockerfile at the root of the archive and the rest of the archive will be used as the context of the build.

When using a Git repository as the build context, the permissions bits for copied files are 644. If a file in the repository has the executable bit set, it will have permissions set to 755. Directories have permissions set to 755.
Pattern matching

For local files, each <src> may contain wildcards and matching will be done using Go's filepath.Match

rules.

For example, to add all files and directories in the root of the build context ending with .png:

COPY *.png /dest/

In the following example, ? is a single-character wildcard, matching e.g. index.js and index.ts.

COPY index.?s /dest/

When adding files or directories that contain special characters (such as [ and ]), you need to escape those paths following the Golang rules to prevent them from being treated as a matching pattern. For example, to add a file named arr[0].txt, use the following;

COPY arr[[]0].txt /dest/

Destination

If the destination path begins with a forward slash, it's interpreted as an absolute path, and the source files are copied into the specified destination relative to the root of the current build stage.

```Dockerfile
# create /abs/test.txt
COPY test.txt /abs/
```

Trailing slashes are significant. For example, COPY test.txt /abs creates a file at /abs, whereas COPY test.txt /abs/ creates /abs/test.txt.

If the destination path doesn't begin with a leading slash, it's interpreted as relative to the working directory of the build container.

```Dockerfile
WORKDIR /usr/src/app
# create /usr/src/app/rel/test.txt
COPY test.txt rel/
```

If destination doesn't exist, it's created, along with all missing directories in its path.

If the source is a file, and the destination doesn't end with a trailing slash, the source file will be written to the destination path as a file.
COPY --from

By default, the COPY instruction copies files from the build context. The COPY --from flag lets you copy files from an image, a build stage, or a named context instead.

COPY [--from=<image|stage|context>] <src> ... <dest>

To copy from a build stage in a multi-stage build

, specify the name of the stage you want to copy from. You specify stage names using the AS keyword with the FROM instruction.

```Dockerfile
# syntax=docker/dockerfile:1
FROM alpine AS build
COPY . .
RUN apk add clang
RUN clang -o /hello hello.c

FROM scratch
COPY --from=build /hello /
```

You can also copy files directly from named contexts (specified with --build-context <name>=<source>) or images. The following example copies an nginx.conf file from the official Nginx image.

COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf

The source path of COPY --from is always resolved from filesystem root of the image or stage that you specify.
COPY --chown --chmod

Note

Only octal notation is currently supported. Non-octal support is tracked in moby/buildkit#1951.

COPY [--chown=<user>:<group>] [--chmod=<perms> ...] <src> ... <dest>

The --chown and --chmod features are only supported on Dockerfiles used to build Linux containers, and doesn't work on Windows containers. Since user and group ownership concepts do not translate between Linux and Windows, the use of /etc/passwd and /etc/group for translating user and group names to IDs restricts this feature to only be viable for Linux OS-based containers.

All files and directories copied from the build context are created with a UID and GID of 0 unless the optional --chown flag specifies a given username, groupname, or UID/GID combination to request specific ownership of the copied content. The format of the --chown flag allows for either username and groupname strings or direct integer UID and GID in any combination. Providing a username without groupname or a UID without GID will use the same numeric UID as the GID. If a username or groupname is provided, the container's root filesystem /etc/passwd and /etc/group files will be used to perform the translation from name to integer UID or GID respectively. The following examples show valid definitions for the --chown flag:

COPY --chown=55:mygroup files* /somedir/
COPY --chown=bin files* /somedir/
COPY --chown=1 files* /somedir/
COPY --chown=10:11 files* /somedir/
COPY --chown=myuser:mygroup --chmod=644 files* /somedir/

If the container root filesystem doesn't contain either /etc/passwd or /etc/group files and either user or group names are used in the --chown flag, the build will fail on the COPY operation. Using numeric IDs requires no lookup and does not depend on container root filesystem content.

With the Dockerfile syntax version 1.10.0 and later, the --chmod flag supports variable interpolation, which lets you define the permission bits using build arguments:

```Dockerfile
# syntax=docker/dockerfile:1.10
FROM alpine
WORKDIR /src
ARG MODE=440
COPY --chmod=$MODE . .

COPY --link

COPY [--link[=<boolean>]] <src> ... <dest>
```

Enabling this flag in COPY or ADD commands allows you to copy files with enhanced semantics where your files remain independent on their own layer and don't get invalidated when commands on previous layers are changed.

When --link is used your source files are copied into an empty destination directory. That directory is turned into a layer that is linked on top of your previous state.

```Dockerfile
# syntax=docker/dockerfile:1
FROM alpine
COPY --link /foo /bar
```

Is equivalent of doing two builds:

FROM alpine

and

FROM scratch
COPY /foo /bar

and merging all the layers of both images together.
Benefits of using --link

Use --link to reuse already built layers in subsequent builds with --cache-from even if the previous layers have changed. This is especially important for multi-stage builds where a COPY --from statement would previously get invalidated if any previous commands in the same stage changed, causing the need to rebuild the intermediate stages again. With --link the layer the previous build generated is reused and merged on top of the new layers. This also means you can easily rebase your images when the base images receive updates, without having to execute the whole build again. In backends that support it, BuildKit can do this rebase action without the need to push or pull any layers between the client and the registry. BuildKit will detect this case and only create new image manifest that contains the new layers and old layers in correct order.

The same behavior where BuildKit can avoid pulling down the base image can also happen when using --link and no other commands that would require access to the files in the base image. In that case BuildKit will only build the layers for the COPY commands and push them to the registry directly on top of the layers of the base image.
Incompatibilities with --link=false

When using --link the COPY/ADD commands are not allowed to read any files from the previous state. This means that if in previous state the destination directory was a path that contained a symlink, COPY/ADD can not follow it. In the final image the destination path created with --link will always be a path containing only directories.

If you don't rely on the behavior of following symlinks in the destination path, using --link is always recommended. The performance of --link is equivalent or better than the default behavior and, it creates much better conditions for cache reuse.
COPY --parents

    Note

    Not yet available in stable syntax, use docker/dockerfile:1.7-labs version.

COPY [--parents[=<boolean>]] <src> ... <dest>

The --parents flag preserves parent directories for src entries. This flag defaults to false.

```Dockerfile
# syntax=docker/dockerfile:1-labs
FROM scratch

COPY ./x/a.txt ./y/a.txt /no_parents/
COPY --parents ./x/a.txt ./y/a.txt /parents/

# /no_parents/a.txt
# /parents/x/a.txt
# /parents/y/a.txt
```

This behavior is similar to the Linux cp utility's
--parents or rsync

--relative flag.

As with Rsync, it is possible to limit which parent directories are preserved by inserting a dot and a slash (./) into the source path. If such point exists, only parent directories after it will be preserved. This may be especially useful copies between stages with --from where the source paths need to be absolute.

```Dockerfile
# syntax=docker/dockerfile:1-labs
FROM scratch

COPY --parents ./x/./y/*.txt /parents/

# Build context:
# ./x/y/a.txt
# ./x/y/b.txt
#
# Output:
# /parents/y/a.txt
# /parents/y/b.txt
```

Note that, without the --parents flag specified, any filename collision will fail the Linux cp operation with an explicit error message (cp: will not overwrite just-created './x/a.txt' with './y/a.txt'), where the Buildkit will silently overwrite the target file at the destination.

While it is possible to preserve the directory structure for COPY instructions consisting of only one src entry, usually it is more beneficial to keep the layer count in the resulting image as low as possible. Therefore, with the --parents flag, the Buildkit is capable of packing multiple COPY instructions together, keeping the directory structure intact.
COPY --exclude

    Note

    Not yet available in stable syntax, use docker/dockerfile:1.7-labs version.

COPY [--exclude=<path> ...] <src> ... <dest>

The --exclude flag lets you specify a path expression for files to be excluded.

The path expression follows the same format as <src>, supporting wildcards and matching using Go's filepath.Match

rules. For example, to add all files starting with "hom", excluding files with a .txt extension:

```Dockerfile
# syntax=docker/dockerfile:1-labs
FROM scratch

COPY --exclude=*.txt hom* /mydir/
```

You can specify the --exclude option multiple times for a COPY instruction. Multiple --excludes are files matching its patterns not to be copied, even if the files paths match the pattern specified in <src>. To add all files starting with "hom", excluding files with either .txt or .md extensions:

```Dockerfile

# syntax=docker/dockerfile:1-labs
FROM scratch

COPY --exclude=*.txt --exclude=*.md hom* /mydir/
```

ADD

ADD has two forms. The latter form is required for paths containing whitespace.

ADD [OPTIONS] <src> ... <dest>
ADD [OPTIONS] ["<src>", ... "<dest>"]

The available [OPTIONS] are:
Option	Minimum Dockerfile version
--keep-git-dir	1.1
--checksum	1.6
--chown	
--chmod	1.2
--link	1.4
--exclude	1.7-labs

The ADD instruction copies new files or directories from <src> and adds them to the filesystem of the image at the path <dest>. Files and directories can be copied from the build context, a remote URL, or a Git repository.

The ADD and COPY instructions are functionally similar, but serve slightly different purposes. Learn more about the differences between ADD and COPY

.
Source

You can specify multiple source files or directories with ADD. The last argument must always be the destination. For example, to add two files, file1.txt and file2.txt, from the build context to /usr/src/things/ in the build container:

ADD file1.txt file2.txt /usr/src/things/

If you specify multiple source files, either directly or using a wildcard, then the destination must be a directory (must end with a slash /).

To add files from a remote location, you can specify a URL or the address of a Git repository as the source. For example:

ADD https://example.com/archive.zip /usr/src/things/
ADD git@github.com:user/repo.git /usr/src/things/

BuildKit detects the type of <src> and processes it accordingly.

    If <src> is a local file or directory, the contents of the directory are copied to the specified destination. See Adding files from the build context.
    If <src> is a local tar archive, it is decompressed and extracted to the specified destination. See Adding local tar archives.
    If <src> is a URL, the contents of the URL are downloaded and placed at the specified destination. See Adding files from a URL.
    If <src> is a Git repository, the repository is cloned to the specified destination. See Adding files from a Git repository.

Adding files from the build context

Any relative or local path that doesn't begin with a http://, https://, or git@ protocol prefix is considered a local file path. The local file path is relative to the build context. For example, if the build context is the current directory, ADD file.txt / adds the file at ./file.txt to the root of the filesystem in the build container.

Specifying a source path with a leading slash or one that navigates outside the build context, such as ADD ../something /something, automatically removes any parent directory navigation (../). Trailing slashes in the source path are also disregarded, making ADD something/ /something equivalent to ADD something /something.

If the source is a directory, the contents of the directory are copied, including filesystem metadata. The directory itself isn't copied, only its contents. If it contains subdirectories, these are also copied, and merged with any existing directories at the destination. Any conflicts are resolved in favor of the content being added, on a file-by-file basis, except if you're trying to copy a directory onto an existing file, in which case an error is raised.

If the source is a file, the file and its metadata are copied to the destination. File permissions are preserved. If the source is a file and a directory with the same name exists at the destination, an error is raised.

If you pass a Dockerfile through stdin to the build (docker build - < Dockerfile), there is no build context. In this case, you can only use the ADD instruction to copy remote files. You can also pass a tar archive through stdin: (docker build - < archive.tar), the Dockerfile at the root of the archive and the rest of the archive will be used as the context of the build.
Pattern matching

For local files, each <src> may contain wildcards and matching will be done using Go's filepath.Match

rules.

For example, to add all files and directories in the root of the build context ending with .png:

ADD *.png /dest/

In the following example, ? is a single-character wildcard, matching e.g. index.js and index.ts.

ADD index.?s /dest/

When adding files or directories that contain special characters (such as [ and ]), you need to escape those paths following the Golang rules to prevent them from being treated as a matching pattern. For example, to add a file named arr[0].txt, use the following;

ADD arr[[]0].txt /dest/

Adding local tar archives

When using a local tar archive as the source for ADD, and the archive is in a recognized compression format (gzip, bzip2 or xz, or uncompressed), the archive is decompressed and extracted into the specified destination. Only local tar archives are extracted. If the tar archive is a remote URL, the archive is not extracted, but downloaded and placed at the destination.

When a directory is extracted, it has the same behavior as tar -x. The result is the union of:

    Whatever existed at the destination path, and
    The contents of the source tree, with conflicts resolved in favor of the content being added, on a file-by-file basis.

    Note

    Whether a file is identified as a recognized compression format or not is done solely based on the contents of the file, not the name of the file. For example, if an empty file happens to end with .tar.gz this isn't recognized as a compressed file and doesn't generate any kind of decompression error message, rather the file will simply be copied to the destination.

Adding files from a URL

In the case where source is a remote file URL, the destination will have permissions of 600. If the HTTP response contains a Last-Modified header, the timestamp from that header will be used to set the mtime on the destination file. However, like any other file processed during an ADD, mtime isn't included in the determination of whether or not the file has changed and the cache should be updated.

If the destination ends with a trailing slash, then the filename is inferred from the URL path. For example, ADD http://example.com/foobar / would create the file /foobar. The URL must have a nontrivial path so that an appropriate filename can be discovered (http://example.com doesn't work).

If the destination doesn't end with a trailing slash, the destination path becomes the filename of the file downloaded from the URL. For example, ADD http://example.com/foo /bar creates the file /bar.

If your URL files are protected using authentication, you need to use RUN wget, RUN curl or use another tool from within the container as the ADD instruction doesn't support authentication.
Adding files from a Git repository

To use a Git repository as the source for ADD, you can reference the repository's HTTP or SSH address as the source. The repository is cloned to the specified destination in the image.

ADD https://github.com/user/repo.git /mydir/

You can use URL fragments to specify a specific branch, tag, commit, or subdirectory. For example, to add the docs directory of the v0.14.1 tag of the buildkit repository:

ADD git@github.com:moby/buildkit.git#v0.14.1:docs /buildkit-docs

For more information about Git URL fragments, see URL fragments

.

When adding from a Git repository, the permissions bits for files are 644. If a file in the repository has the executable bit set, it will have permissions set to 755. Directories have permissions set to 755.

When using a Git repository as the source, the repository must be accessible from the build context. To add a repository via SSH, whether public or private, you must pass an SSH key for authentication. For example, given the following Dockerfile:

```Dockerfile
# syntax=docker/dockerfile:1
FROM alpine
ADD git@git.example.com:foo/bar.git /bar
```

To build this Dockerfile, pass the --ssh flag to the docker build to mount the SSH agent socket to the build. For example:

```bash
docker build --ssh default .
```

Destination - If the destination path begins with a forward slash, it's interpreted as an absolute path, and the source files are copied into the specified destination relative to the root of the current build stage.

```Dockerfile
# create /abs/test.txt
ADD test.txt /abs/
```

Trailing slashes are significant. For example, ADD test.txt /abs creates a file at /abs, whereas ADD test.txt /abs/ creates /abs/test.txt.

If the destination path doesn't begin with a leading slash, it's interpreted as relative to the working directory of the build container.

```Dockerfile
WORKDIR /usr/src/app
# create /usr/src/app/rel/test.txt
ADD test.txt rel/
```

If destination doesn't exist, it's created, along with all missing directories in its path.

If the source is a file, and the destination doesn't end with a trailing slash, the source file will be written to the destination path as a file.
ADD --keep-git-dir

ADD [--keep-git-dir=<boolean>] <src> ... <dir>

When <src> is the HTTP or SSH address of a remote Git repository, BuildKit adds the contents of the Git repository to the image excluding the .git directory by default.

The --keep-git-dir=true flag lets you preserve the .git directory.

# syntax=docker/dockerfile:1
FROM alpine
ADD --keep-git-dir=true https://github.com/moby/buildkit.git#v0.10.1 /buildkit

ADD --checksum

ADD [--checksum=<hash>] <src> ... <dir>

The --checksum flag lets you verify the checksum of a remote resource. The checksum is formatted as sha256:<hash>. SHA-256 is the only supported hash algorithm.

ADD --checksum=sha256:24454f830cdb571e2c4ad15481119c43b3cafd48dd869a9b2945d1036d1dc68d https://mirrors.edge.kernel.org/pub/linux/kernel/Historic/linux-0.01.tar.gz /

The --checksum flag only supports HTTP(S) sources.
ADD --chown --chmod

See COPY --chown --chmod.
ADD --link

See COPY --link.
ADD --exclude

See COPY --exclude.

`EXPOSE` - EXPOSE <port> [<port>/<protocol>...] - The EXPOSE instruction informs Docker that the container listens on the specified network ports at runtime. You can specify whether the port listens on TCP or UDP, and the default is TCP if you don't specify a protocol.

The EXPOSE instruction doesn't actually publish the port. It functions as a type of documentation between the person who builds the image and the person who runs the container, about which ports are intended to be published. To publish the port when running the container, use the -p flag on docker run to publish and map one or more ports, or the -P flag to publish all exposed ports and map them to high-order ports.

By default, EXPOSE assumes TCP. You can also specify UDP:

```Dockerfile
EXPOSE 80/udp
```

To expose on both TCP and UDP, include two lines:

```Dockerfile
EXPOSE 80/tcp
EXPOSE 80/udp
EXPOSE $PORT
```

In this case, if you use -P with docker run, the port will be exposed once for TCP and once for UDP. Remember that -P uses an ephemeral high-ordered host port on the host, so TCP and UDP doesn't use the same port.

Regardless of the EXPOSE settings, you can override them at runtime by using the -p flag. For example

```bash
docker run -p 80:80/tcp -p 80:80/udp ...
```

To set up port redirection on the host system, see using the -P flag
. The docker network command supports creating networks for communication among containers without the need to expose or publish specific ports, because the containers connected to the network can communicate with each other over any port. For detailed information, see the overview of this feature.

`ENV` - ENV <key>=<value> [<key>=<value>...] - The ENV instruction sets the environment variable <key> to the value <value>. This value will be in the environment for all subsequent instructions in the build stage and can be replaced inline in many as well. The value will be interpreted for other environment variables, so quote characters will be removed if they are not escaped. Like command line parsing, quotes and backslashes can be used to include spaces within values.

Available inside of Dockerfile and application code.Set via ENV in Dockerfile or via --env on docker run.

Example:

```Dockerfile
ENV MY_NAME="John Doe"
ENV MY_DOG=Rex\ The\ Dog
ENV MY_CAT=fluffy
```

The ENV instruction allows for multiple <key>=<value> ... variables to be set at one time, and the example below will yield the same net results in the final image:

```Dockerfile
ENV MY_NAME="John Doe" MY_DOG=Rex\ The\ Dog \
    MY_CAT=fluffy
```

The environment variables set using ENV will persist when a container is run from the resulting image. You can view the values using docker inspect, and change them using docker run --env <key>=<value>.

A stage inherits any environment variables that were set using ENV by its parent stage or any ancestor.
Environment variable persistence can cause unexpected side effects. For example, setting ENV DEBIAN_FRONTEND=noninteractive changes the behavior of apt-get, and may confuse users of your image.

If an environment variable is only needed during build, and not in the final image, consider setting a value for a single command instead:

```Dockerfile
RUN DEBIAN_FRONTEND=noninteractive apt-get update && apt-get install -y ...
```

Or using ARG, which is not persisted in the final image:

```Dockerfile
ARG DEBIAN_FRONTEND=noninteractive
RUN apt-get update && apt-get install -y ...
```

Alternative syntax - The ENV instruction also allows an alternative syntax ENV <key> <value>, omitting the =. For example:

```Dockerfile
ENV MY_VAR my-value
ENV PORT 8080
```

This syntax does not allow for multiple environment-variables to be set in a single ENV instruction, and can be confusing. For example, the following sets a single environment variable (ONE) with value "TWO= THREE=world":

```Dockerfile
ENV ONE TWO= THREE=world
```

The alternative syntax is supported for backward compatibility, but discouraged for the reasons outlined above, and may be removed in a future release.

`ARG` - ARG <name>[=<default value>] [<name>[=<default value>]...] - The ARG instruction defines a variable that users can pass at build-time to the builder with the docker build command using the --build-arg <varname>=<value> flag.

It is only available inside of Dockerfile,NOT accessible in CMD or any application code.Set on image build via --build-arg

NOTE:- It isn't recommended to use build arguments for passing secrets such as user credentials, API tokens, etc. Build arguments are visible in the docker history command and in max mode provenance attestations, which are attached to the image by default if you use the Buildx GitHub Actions and your GitHub repository is public.

A Dockerfile may include one or more ARG instructions. For example, the following is a valid Dockerfile:

```Dockerfile
FROM busybox
ARG user1
ARG buildno
# ...
```

Default values - An ARG instruction can optionally include a default value:

```Dockerfile
FROM busybox
ARG user1=someuser
ARG buildno=1
# ...
```

If an ARG instruction has a default value and if there is no value passed at build-time, the builder uses the default.
Scope

An ARG variable comes into effect from the line on which it is declared in the Dockerfile. For example, consider this Dockerfile:

FROM busybox
USER ${username:-some_user}
ARG username
USER $username
# ...

A user builds this file by calling:

 docker build --build-arg username=what_user .

    The USER instruction on line 2 evaluates to the some_user fallback, because the username variable is not yet declared.
    The username variable is declared on line 3, and available for reference in Dockerfile instruction from that point onwards.
    The USER instruction on line 4 evaluates to what_user, since at that point the username argument has a value of what_user which was passed on the command line. Prior to its definition by an ARG instruction, any use of a variable results in an empty string.

An ARG variable declared within a build stage is automatically inherited by other stages based on that stage. Unrelated build stages do not have access to the variable. To use an argument in multiple distinct stages, each stage must include the ARG instruction, or they must both be based on a shared base stage in the same Dockerfile where the variable is declared.

For more information, refer to variable scoping

.
Using ARG variables

You can use an ARG or an ENV instruction to specify variables that are available to the RUN instruction. Environment variables defined using the ENV instruction always override an ARG instruction of the same name. Consider this Dockerfile with an ENV and ARG instruction.

FROM ubuntu
ARG CONT_IMG_VER
ENV CONT_IMG_VER=v1.0.0
RUN echo $CONT_IMG_VER

Then, assume this image is built with this command:

 docker build --build-arg CONT_IMG_VER=v2.0.1 .

In this case, the RUN instruction uses v1.0.0 instead of the ARG setting passed by the user:v2.0.1 This behavior is similar to a shell script where a locally scoped variable overrides the variables passed as arguments or inherited from environment, from its point of definition.

Using the example above but a different ENV specification you can create more useful interactions between ARG and ENV instructions:

FROM ubuntu
ARG CONT_IMG_VER
ENV CONT_IMG_VER=${CONT_IMG_VER:-v1.0.0}
RUN echo $CONT_IMG_VER

Unlike an ARG instruction, ENV values are always persisted in the built image. Consider a docker build without the --build-arg flag:

 docker build .

Using this Dockerfile example, CONT_IMG_VER is still persisted in the image but its value would be v1.0.0 as it is the default set in line 3 by the ENV instruction.

The variable expansion technique in this example allows you to pass arguments from the command line and persist them in the final image by leveraging the ENV instruction. Variable expansion is only supported for a limited set of Dockerfile instructions.
Predefined ARGs

Docker has a set of predefined ARG variables that you can use without a corresponding ARG instruction in the Dockerfile.

    HTTP_PROXY
    http_proxy
    HTTPS_PROXY
    https_proxy
    FTP_PROXY
    ftp_proxy
    NO_PROXY
    no_proxy
    ALL_PROXY
    all_proxy

To use these, pass them on the command line using the --build-arg flag, for example:

 docker build --build-arg HTTPS_PROXY=https://my-proxy.example.com .

By default, these pre-defined variables are excluded from the output of docker history. Excluding them reduces the risk of accidentally leaking sensitive authentication information in an HTTP_PROXY variable.

For example, consider building the following Dockerfile using --build-arg HTTP_PROXY=http://user:pass@proxy.lon.example.com

FROM ubuntu
RUN echo "Hello World"

In this case, the value of the HTTP_PROXY variable is not available in the docker history and is not cached. If you were to change location, and your proxy server changed to http://user:pass@proxy.sfo.example.com, a subsequent build does not result in a cache miss.

If you need to override this behaviour then you may do so by adding an ARG statement in the Dockerfile as follows:

FROM ubuntu
ARG HTTP_PROXY
RUN echo "Hello World"

When building this Dockerfile, the HTTP_PROXY is preserved in the docker history, and changing its value invalidates the build cache.
Automatic platform ARGs in the global scope

This feature is only available when using the BuildKit

backend.

BuildKit supports a predefined set of ARG variables with information on the platform of the node performing the build (build platform) and on the platform of the resulting image (target platform). The target platform can be specified with the --platform flag on docker build.

The following ARG variables are set automatically:

    TARGETPLATFORM - platform of the build result. Eg linux/amd64, linux/arm/v7, windows/amd64.
    TARGETOS - OS component of TARGETPLATFORM
    TARGETARCH - architecture component of TARGETPLATFORM
    TARGETVARIANT - variant component of TARGETPLATFORM
    BUILDPLATFORM - platform of the node performing the build.
    BUILDOS - OS component of BUILDPLATFORM
    BUILDARCH - architecture component of BUILDPLATFORM
    BUILDVARIANT - variant component of BUILDPLATFORM

These arguments are defined in the global scope so are not automatically available inside build stages or for your RUN commands. To expose one of these arguments inside the build stage redefine it without value.

For example:

FROM alpine
ARG TARGETPLATFORM
RUN echo "I'm building for $TARGETPLATFORM"

BuildKit built-in build args
Arg	Type	Description
BUILDKIT_CACHE_MOUNT_NS	String	Set optional cache ID namespace.
BUILDKIT_CONTEXT_KEEP_GIT_DIR	Bool	Trigger Git context to keep the .git directory.
BUILDKIT_INLINE_CACHE2	Bool	Inline cache metadata to image config or not.
BUILDKIT_MULTI_PLATFORM	Bool	Opt into deterministic output regardless of multi-platform output or not.
BUILDKIT_SANDBOX_HOSTNAME	String	Set the hostname (default buildkitsandbox)
BUILDKIT_SYNTAX	String	Set frontend image
SOURCE_DATE_EPOCH	Int	Set the Unix timestamp for created image and layers. More info from reproducible builds
. Supported since Dockerfile 1.5, BuildKit 0.11
Example: keep .git dir

When using a Git context, .git dir is not kept on checkouts. It can be useful to keep it around if you want to retrieve git information during your build:

# syntax=docker/dockerfile:1
FROM alpine
WORKDIR /src
RUN --mount=target=. \
  make REVISION=$(git rev-parse HEAD) build

 docker build --build-arg BUILDKIT_CONTEXT_KEEP_GIT_DIR=1 https://github.com/user/repo.git#main

Impact on build caching

ARG variables are not persisted into the built image as ENV variables are. However, ARG variables do impact the build cache in similar ways. If a Dockerfile defines an ARG variable whose value is different from a previous build, then a "cache miss" occurs upon its first usage, not its definition. In particular, all RUN instructions following an ARG instruction use the ARG variable implicitly (as an environment variable), thus can cause a cache miss. All predefined ARG variables are exempt from caching unless there is a matching ARG statement in the Dockerfile.

For example, consider these two Dockerfile:

FROM ubuntu
ARG CONT_IMG_VER
RUN echo $CONT_IMG_VER

FROM ubuntu
ARG CONT_IMG_VER
RUN echo hello

If you specify --build-arg CONT_IMG_VER=<value> on the command line, in both cases, the specification on line 2 doesn't cause a cache miss; line 3 does cause a cache miss. ARG CONT_IMG_VER causes the RUN line to be identified as the same as running CONT_IMG_VER=<value> echo hello, so if the <value> changes, you get a cache miss.

Consider another example under the same command line:

FROM ubuntu
ARG CONT_IMG_VER
ENV CONT_IMG_VER=$CONT_IMG_VER
RUN echo $CONT_IMG_VER

In this example, the cache miss occurs on line 3. The miss happens because the variable's value in the ENV references the ARG variable and that variable is changed through the command line. In this example, the ENV command causes the image to include the value.

If an ENV instruction overrides an ARG instruction of the same name, like this Dockerfile:

FROM ubuntu
ARG CONT_IMG_VER
ENV CONT_IMG_VER=hello
RUN echo $CONT_IMG_VER

Line 3 doesn't cause a cache miss because the value of CONT_IMG_VER is a constant (hello). As a result, the environment variables and values used on the RUN (line 4) doesn't change between builds.

ONBUILD

ONBUILD INSTRUCTION

The ONBUILD instruction adds to the image a trigger instruction to be executed at a later time, when the image is used as the base for another build. The trigger will be executed in the context of the downstream build, as if it had been inserted immediately after the FROM instruction in the downstream Dockerfile.

This is useful if you are building an image which will be used as a base to build other images, for example an application build environment or a daemon which may be customized with user-specific configuration.

For example, if your image is a reusable Python application builder, it will require application source code to be added in a particular directory, and it might require a build script to be called after that. You can't just call ADD and RUN now, because you don't yet have access to the application source code, and it will be different for each application build. You could simply provide application developers with a boilerplate Dockerfile to copy-paste into their application, but that's inefficient, error-prone and difficult to update because it mixes with application-specific code.

The solution is to use ONBUILD to register advance instructions to run later, during the next build stage.

Here's how it works:

    When it encounters an ONBUILD instruction, the builder adds a trigger to the metadata of the image being built. The instruction doesn't otherwise affect the current build.
    At the end of the build, a list of all triggers is stored in the image manifest, under the key OnBuild. They can be inspected with the docker inspect command.
    Later the image may be used as a base for a new build, using the FROM instruction. As part of processing the FROM instruction, the downstream builder looks for ONBUILD triggers, and executes them in the same order they were registered. If any of the triggers fail, the FROM instruction is aborted which in turn causes the build to fail. If all triggers succeed, the FROM instruction completes and the build continues as usual.
    Triggers are cleared from the final image after being executed. In other words they aren't inherited by "grand-children" builds.

For example you might add something like this:

ONBUILD ADD . /app/src
ONBUILD RUN /usr/local/bin/python-build --dir /app/src

Copy or mount from stage, image, or context

As of Dockerfile syntax 1.11, you can use ONBUILD with instructions that copy or mount files from other stages, images, or build contexts. For example:

# syntax=docker/dockerfile:1.11
FROM alpine AS baseimage
ONBUILD COPY --from=build /usr/bin/app /app
ONBUILD RUN --mount=from=config,target=/opt/appconfig ...

If the source of from is a build stage, the stage must be defined in the Dockerfile where ONBUILD gets triggered. If it's a named context, that context must be passed to the downstream build.
ONBUILD limitations

    Chaining ONBUILD instructions using ONBUILD ONBUILD isn't allowed.
    The ONBUILD instruction may not trigger FROM or MAINTAINER instructions.

STOPSIGNAL

STOPSIGNAL signal

The STOPSIGNAL instruction sets the system call signal that will be sent to the container to exit. This signal can be a signal name in the format SIG<NAME>, for instance SIGKILL, or an unsigned number that matches a position in the kernel's syscall table, for instance 9. The default is SIGTERM if not defined.

The image's default stopsignal can be overridden per container, using the --stop-signal flag on docker run and docker create.
HEALTHCHECK

The HEALTHCHECK instruction has two forms:

    HEALTHCHECK [OPTIONS] CMD command (check container health by running a command inside the container)
    HEALTHCHECK NONE (disable any healthcheck inherited from the base image)

The HEALTHCHECK instruction tells Docker how to test a container to check that it's still working. This can detect cases such as a web server stuck in an infinite loop and unable to handle new connections, even though the server process is still running.

When a container has a healthcheck specified, it has a health status in addition to its normal status. This status is initially starting. Whenever a health check passes, it becomes healthy (whatever state it was previously in). After a certain number of consecutive failures, it becomes unhealthy.

The options that can appear before CMD are:

    --interval=DURATION (default: 30s)
    --timeout=DURATION (default: 30s)
    --start-period=DURATION (default: 0s)
    --start-interval=DURATION (default: 5s)
    --retries=N (default: 3)

The health check will first run interval seconds after the container is started, and then again interval seconds after each previous check completes.

If a single run of the check takes longer than timeout seconds then the check is considered to have failed.

It takes retries consecutive failures of the health check for the container to be considered unhealthy.

start period provides initialization time for containers that need time to bootstrap. Probe failure during that period will not be counted towards the maximum number of retries. However, if a health check succeeds during the start period, the container is considered started and all consecutive failures will be counted towards the maximum number of retries.

start interval is the time between health checks during the start period. This option requires Docker Engine version 25.0 or later.

There can only be one HEALTHCHECK instruction in a Dockerfile. If you list more than one then only the last HEALTHCHECK will take effect.

The command after the CMD keyword can be either a shell command (e.g. HEALTHCHECK CMD /bin/check-running) or an exec array (as with other Dockerfile commands; see e.g. ENTRYPOINT for details).

The command's exit status indicates the health status of the container. The possible values are:

    0: success - the container is healthy and ready for use
    1: unhealthy - the container isn't working correctly
    2: reserved - don't use this exit code

For example, to check every five minutes or so that a web-server is able to serve the site's main page within three seconds:

HEALTHCHECK --interval=5m --timeout=3s \
  CMD curl -f http://localhost/ || exit 1

To help debug failing probes, any output text (UTF-8 encoded) that the command writes on stdout or stderr will be stored in the health status and can be queried with docker inspect. Such output should be kept short (only the first 4096 bytes are stored currently).

When the health status of a container changes, a health_status event is generated with the new status.
SHELL

SHELL ["executable", "parameters"]

The SHELL instruction allows the default shell used for the shell form of commands to be overridden. The default shell on Linux is ["/bin/sh", "-c"], and on Windows is ["cmd", "/S", "/C"]. The SHELL instruction must be written in JSON form in a Dockerfile.

The SHELL instruction is particularly useful on Windows where there are two commonly used and quite different native shells: cmd and powershell, as well as alternate shells available including sh.

The SHELL instruction can appear multiple times. Each SHELL instruction overrides all previous SHELL instructions, and affects all subsequent instructions. For example:

FROM microsoft/windowsservercore

# Executed as cmd /S /C echo default
RUN echo default

# Executed as cmd /S /C powershell -command Write-Host default
RUN powershell -command Write-Host default

# Executed as powershell -command Write-Host hello
SHELL ["powershell", "-command"]
RUN Write-Host hello

# Executed as cmd /S /C echo hello
SHELL ["cmd", "/S", "/C"]
RUN echo hello

The following instructions can be affected by the SHELL instruction when the shell form of them is used in a Dockerfile: RUN, CMD and ENTRYPOINT.

The following example is a common pattern found on Windows which can be streamlined by using the SHELL instruction:

RUN powershell -command Execute-MyCmdlet -param1 "c:\foo.txt"

The command invoked by the builder will be:

cmd /S /C powershell -command Execute-MyCmdlet -param1 "c:\foo.txt"

This is inefficient for two reasons. First, there is an unnecessary cmd.exe command processor (aka shell) being invoked. Second, each RUN instruction in the shell form requires an extra powershell -command prefixing the command.

To make this more efficient, one of two mechanisms can be employed. One is to use the JSON form of the RUN command such as:

RUN ["powershell", "-command", "Execute-MyCmdlet", "-param1 \"c:\\foo.txt\""]

While the JSON form is unambiguous and does not use the unnecessary cmd.exe, it does require more verbosity through double-quoting and escaping. The alternate mechanism is to use the SHELL instruction and the shell form, making a more natural syntax for Windows users, especially when combined with the escape parser directive:

# escape=`

FROM microsoft/nanoserver
SHELL ["powershell","-command"]
RUN New-Item -ItemType Directory C:\Example
ADD Execute-MyCmdlet.ps1 c:\example\
RUN c:\example\Execute-MyCmdlet -sample 'hello world'

Resulting in:

PS E:\myproject> docker build -t shell .

Sending build context to Docker daemon 4.096 kB
Step 1/5 : FROM microsoft/nanoserver
 ---> 22738ff49c6d
Step 2/5 : SHELL powershell -command
 ---> Running in 6fcdb6855ae2
 ---> 6331462d4300
Removing intermediate container 6fcdb6855ae2
Step 3/5 : RUN New-Item -ItemType Directory C:\Example
 ---> Running in d0eef8386e97


    Directory: C:\


Mode         LastWriteTime              Length Name
----         -------------              ------ ----
d-----       10/28/2016  11:26 AM              Example


 ---> 3f2fbf1395d9
Removing intermediate container d0eef8386e97
Step 4/5 : ADD Execute-MyCmdlet.ps1 c:\example\
 ---> a955b2621c31
Removing intermediate container b825593d39fc
Step 5/5 : RUN c:\example\Execute-MyCmdlet 'hello world'
 ---> Running in be6d8e63fe75
hello world
 ---> 8e559e9bf424
Removing intermediate container be6d8e63fe75
Successfully built 8e559e9bf424
PS E:\myproject>

The SHELL instruction could also be used to modify the way in which a shell operates. For example, using SHELL cmd /S /C /V:ON|OFF on Windows, delayed environment variable expansion semantics could be modified.

The SHELL instruction can also be used on Linux should an alternate shell be required such as zsh, csh, tcsh and others.

VOLUME

VOLUME ["/data"]

The VOLUME instruction creates a mount point with the specified name and marks it as holding externally mounted volumes from native host or other containers. The value can be a JSON array, VOLUME ["/var/log/"], or a plain string with multiple arguments, such as VOLUME /var/log or VOLUME /var/log /var/db. For more information/examples and mounting instructions via the Docker client, refer to Share Directories via Volumes

documentation.

The docker run command initializes the newly created volume with any data that exists at the specified location within the base image. For example, consider the following Dockerfile snippet:

FROM ubuntu
RUN mkdir /myvol
RUN echo "hello world" > /myvol/greeting
VOLUME /myvol

This Dockerfile results in an image that causes docker run to create a new mount point at /myvol and copy the greeting file into the newly created volume.
Notes about specifying volumes

Keep the following things in mind about volumes in the Dockerfile.

    Volumes on Windows-based containers: When using Windows-based containers, the destination of a volume inside the container must be one of:
        a non-existing or empty directory
        a drive other than C:

    Changing the volume from within the Dockerfile: If any build steps change the data within the volume after it has been declared, those changes will be discarded when using the legacy builder. When using Buildkit, the changes will instead be kept.

    JSON formatting: The list is parsed as a JSON array. You must enclose words with double quotes (") rather than single quotes (').

    The host directory is declared at container run-time: The host directory (the mountpoint) is, by its nature, host-dependent. This is to preserve image portability, since a given host directory can't be guaranteed to be available on all hosts. For this reason, you can't mount a host directory from within the Dockerfile. The VOLUME instruction does not support specifying a host-dir parameter. You must specify the mountpoint when you create or run the container.

USER

USER <user>[:<group>]

or

USER UID[:GID]

The USER instruction sets the user name (or UID) and optionally the user group (or GID) to use as the default user and group for the remainder of the current stage. The specified user is used for RUN instructions and at runtime, runs the relevant ENTRYPOINT and CMD commands.

    Note that when specifying a group for the user, the user will have only the specified group membership. Any other configured group memberships will be ignored.

    Warning

    When the user doesn't have a primary group then the image (or the next instructions) will be run with the root group.

    On Windows, the user must be created first if it's not a built-in account. This can be done with the net user command called as part of a Dockerfile.

FROM microsoft/windowsservercore
# Create Windows user in the container
RUN net user /add patrick
# Set it for subsequent commands
USER patrick

To create image out of Dockerfile

```bash
docker build â€“t <image_name> .
Eg: docker build â€“t learningDocker .
```

( -t = use for tag and .(dot) Use the current directory to build a Docker image using the Dockerfile located in the current directory)

## Building Image from Dockerfile

```bash
# Building image from Dockerfile
docker build -t <image_name> . # Build a Docker image with a given tag
docker build . # Build a Docker image without a tag


# Docker image history
docker image history <image_name> # Show the history of a Docker image
docker image history <image_id> # Show the history of a Docker image with a given image ID

# Inspect a Docker image
docker image inspect 100229ba687e

# Remove a Docker image
docker image remove <image_name>
docker image remove <image_id> # Remove a Docker image with a given image name and tag

# List Docker images
docker images #Lists all images

# Removing images
docker rmi <image_name>
docker image prune #Remove all unused images
docker image prune -a #remove all images including tagged images

# Inspecting Images
docker image inspect <image_id> # More info about the image
```

## Image tags

Has two parts:-

name : tag--> node:14

name - Defines a group of possible more specialized images e.g node
tag - Defines a specialized image within a group of images e.g 14

Combined it gives a unique identifier.

```bash
docker build -t <image_name>:<tag> . # Build a Docker image with a given name and a tag
docker build -t <image_name> . # Build a Docker image with a name.
```
