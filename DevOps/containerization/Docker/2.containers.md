# What are Containers?

Containers are lightweight, portable, and isolated software environments that allow developers to run and package applications with their dependencies, consistently across different platforms. They help to streamline application development, deployment, and management processes while ensuring that applications run consistently, regardless of the underlying infrastructure.

Containers are standalone executable units that encapsulate all necessary dependencies, libraries, and configuration files required for an application to run consistently across various environments.

## How do containers work?

Unlike traditional virtualization, which emulates a complete operating system with its hardware resources, containers share the host's OS kernel and leverage lightweight virtualization techniques to create isolated processes. This approach leads to several benefits, including:

- **Efficiency**: Containers have less overhead and can share common libraries and executable files, making it possible to run more containers on a single host compared to virtual machines (VMs).
- **Portability**: Containers encapsulate applications and their dependencies, so they can easily be moved and run across different environments and platforms consistently.
- **Fast startup**: Since containers don't need to boot a full OS, they can start up and shut down much faster than VMs.
- **Consistency**: Containers provide a consistent environment for development, testing, and production stages of an application, reducing the "it works on my machine" problem.

## Containers and Docker

Docker is a platform that simplifies the process of creating, deploying, and managing containers. It provides developers and administrators with a set of tools and APIs to manage containerized applications. With Docker, you can build and package application code, libraries, and dependencies into a container image, which can be distributed and run consistently in any environment that supports Docker.

- [@official@What is a container?](https://www.docker.com/resources/what-container/)
- [@feed@Explore top posts about Containers](https://app.daily.dev/tags/containers?ref=roadmapsh)

## Need for Containers

In the world of software development and deployment, consistency and efficiency are crucial. Before containers came into the picture, developers often faced challenges when deploying applications across different environments including:

1. `Inconsistent environments`: Developers often work in different environments which might have different configurations and libraries compared to production servers. This leads to compatibility issues in deploying applications.
2. `Inefficient resource utilization`: Virtual Machines (VMs) were widely used to overcome environment inconsistency. However, VMs require an entire OS to be running for each application, making the resource utilization inefficient.
3. `Slow processes and scalability issues: `Traditional deployment methods have a slower time to market and scaling difficulties, which hinders fast delivery of software updates.

How Containers Address These Challenges is as follows:

- **Consistent environment:** Containers solve environment inconsistencies by bundling an application and its dependencies, configurations, and libraries into a single container. This guarantees that the application runs smoothly across different environments.
- **Efficient resource utilization:** Unlike VMs, containers share underlying system resources and OS kernel, which makes them lightweight and efficient. Containers are designed to use fewer resources and boot up faster, improving resource utilization.
- **Faster processes and scalability:** Containers can be easily created, destroyed, and replaced, leading to faster development and deployment cycles. Scaling applications becomes easier as multiple containers can be deployed without consuming significant resources.

Overall, containers have become an essential tool for organizations that want to respond quickly to market changes, improve resource efficiency, and ensure reliable and consistent software delivery. They have revolutionized modern software development practices and have long-lasting impact in the world of deployment and application management.

- [@article@Introduction to containers - AWS Skill Builder](https://explore.skillbuilder.aws/learn/course/106/introduction-to-containers)
- [@feed@Explore top posts about Containers](https://app.daily.dev/tags/containers?ref=roadmapsh)

## Bare Metal vs VM vs Containers

Here is a quick overview of the differences between bare metal, virtual machines, and containers.

### Bare Metal

Bare metal is a term used to describe a computer that is running directly on the hardware without any virtualization. This is the most performant way to run an application, but it is also the least flexible. You can only run one application per server, and you cannot easily move the application to another server.

### Virtual Machines

Virtual machines (VMs) are a way to run multiple applications on a single server. Each VM runs on top of a hypervisor, which is a piece of software that emulates the hardware of a computer. The hypervisor allows you to run multiple operating systems on a single server, and it also provides isolation between applications running on different VMs.

### Containers

Containers are a way to run multiple applications on a single server without the overhead of a hypervisor. Each container runs on top of a container engine, which is a piece of software that emulates the operating system of a computer. The container engine allows you to run multiple applications on a single server, and it also provides isolation between applications running on different containers.

Containers are created with doker run IMAGE and can be configured with various options/flags.

You can learn more from the following resources:

- [@article@History of Virtualization](https://courses.devopsdirective.com/docker-beginner-to-pro/lessons/01-history-and-motivation/03-history-of-virtualization)
- [@feed@Explore top posts about Containers](https://app.daily.dev/tags/containers?ref=roadmapsh)

```bash

docker container ls # List running containers
docker container ls -a # List all containers, including stopped ones

# Stopping a container
docker container stop f708b7ee1a8b # Stop a running container with a given container ID

# Running a container( docker run creates a new cotainer)
docker run -p 5000:5000 in28min/hello-world-python:0.0.1.RELEASE # Run a Docker container with a Python hello world application
docker run -p 5000:5000 in28min/hello-world-java:0.0.1.RELEASE # Run a Docker container with a Java hello world application
docker run -p 5000:5000 in28min/hello-world-nodejs:0.0.1.RELEASE # Run a Docker container with a Node.js hello world application
docker run -d -p 5000:5000 in28min/hello-world-nodejs:0.0.1.RELEASE # Run a Docker container with a Node.js hello world application in detached mode
docker run -d -p 5001:5000 in28min/hello-world-python:0.0.1.RELEASE # Run a Docker container with a Python hello world application in detached mode
docker run -it <image_name> #Runs image in interactive mode
docker run -rm <image_name> #Automatically removes container after stopping it.

docker run --name <container_name> <image_id> #start container and assign a name.
  
# Getting containers
docker ps #Lists all running containers
docker ps -a # Lists all ccontainers
docker ps --help

# Restarting stopped containers
docker start <container_name> #Using container name but runs in the background(detached mode)
docker start <container_id> #Using container id but runs in the background(detached mode)
docker start -a <container_name> #Using container name but runs in the attached mode(foreground)
docker start -a -i <container_name> # Runs in attached mode with interactive shell

# Attaching to detached container
docker attach <container_name>

# Docker container Logs
docker logs 04e52ff9270f5810eefe1f77222852dc1461c22440d4ecd6228b5c38f09d838e # View the logs of a Docker container
docker logs c2ba # View the logs of a Docker container with a given container ID or name
docker logs -f <container_name> #Attaches a detached container and shows the logs

# Removing unused containers
docker rm <container_name> <cntainer_name> # Removes multiple containers
docker container prune # Removes all stopped containers

# Copy files
docker cp <file_to_be _copied> <container_name:destination> # Copy files into the of running container
docker cp <container_name:destination>  <file_to_be _copied>  #Copy files out of running container

# Remove a Docker container with a given container ID or name
docker container rm 3e657ae9bd16

# List all containers, including stopped ones
docker container ls -a

# Pause a running container with a given container ID or name
docker container pause 832

# Unpause a paused container with a given container ID or name
docker container unpause 832

# Stop a running container with a given container ID or name
docker container stop 832

# Inspect a Docker container with a given container ID or name
docker container inspect ff521fa58db3

# Remove all stopped containers
docker container prune

# Executing a command in Running container
docker exec <container_name> <exec_command>
```

- **Creating and starting a new container**:- When we install software with Docker, we are really using Docker to download or create an image. There are different ways to install an image and several sources for images.

Running the following command will download, install, and start a container running NGINX:

```bash
docker run --detach \
   --name web nginx:latest
```

After Docker has installed and started running NGINX, one line of seemingly random characters will be written to the terminal. It will look something like this:

```bash
7cb5d2b9a7eab87f07182b5bf58936c9947890995b1b94f412912fa822a9ecb5
```

That blob of characters is the unique identifier of the container that was just created to run NGINX. Every time you run docker run and create a new container, that new
container will get a unique identifier.
After the identifier is displayed, it might not seem like anything has happened.That’s because you used the --detach option and started the program in the background. This means that the program started but isn’t attached to your terminal.

Running detached containers is a perfect fit for programs that sit quietly in the background. That type of program is called a daemon, or a service. A daemon generally
interacts with other programs or humans over a network or some other communication channel. When you launch a daemon or other program in a container that you
want to run in the background, remember to use either the --detach flag or its shortform, -d.

- **Running interactive containers**:- Running interactive programs in Docker requires that you bind parts of your terminal to the input or output of a running container.
A terminal-based text editor is a great example of a program that requires an attached terminal. It takes input from the user via a keyboard (and maybe mouse) and displays
output on the terminal. It is interactive over its input and output streams.

```bash
docker run --interactive --tty \
   --link web:web \
   --name web_test \
   busybox:1.29 /bin/sh
```

The command uses two flags on the run command: --interactive (or -i) and --tty (or -t). First, the -`-interactive` option tells Docker to keep the standard input
stream (stdin) open for the container even if no terminal is attached. Second, the `--tty` option tells Docker to allocate a virtual terminal for the container, which will allow you to pass signals to the container. This is usually what you want from an interactive command-line program.

Just as important as the interactive flags, when you started this container, you specified the program to run inside the container. In this case, you ran a shell program
called sh. You can run any program that’s available inside the container.
The command in the interactive container example creates a container, starts a UNIX shell, and is linked to the container that’s running NGINX.

You shut down this interactive container by typing `exit`. This will terminate the shell program and stop the container.

It’s possible to create an interactive container, manually start a process inside that container, and then detach your terminal. You can do so by holding down the Ctrl
(or Control) key and pressing P and then Q. This will work only when you’ve used the --tty option.

- **Listing, stopping, restarting, and viewing output of containers**:-

The first thing you should do to test your current setup is check which containers are currently running by using the docker ps command:

```bash
docker ps
```

Running the command will display the following information about each running container:
1. The container ID
2. The image used
3. The command executed in the container
4. The time since the container was created
5. The duration that the container has been running
6. The network ports exposed by the container
7. The name of the container

You can restart a stopped container with the command:-

```bash
docker restart web
```

Now that your containers are running, you need to test that the system is operating correctly. The best way to do that is to examine the logs for each container. Start
with the web container:

```bash
docker logs web
```

The docker logs command can be helpful for these cases but is dangerous to rely on. Anything that the program writes to the stdout or stderr output streams will be recorded in this log. The problem with this pattern is that the log is never rotated or truncated by default, so the data written to the log for a container will remain and grow as long as the container exists. That long-term persistence can be a problem for long-lived processes. A better way to work with log data uses volumes.

*TIP* - The docker logs command has a flag, --follow or -f, that will display the logs and then continue watching and updating the display with changes
to the log as they occur. When you’ve finished, press Ctrl-C (or Command-C) to interrupt the logs command.