# Docker Compose

Docker Compose is a tool for defining and running multi-container Docker applications. It allows users to describe the services, networks, and volumes in a docker-compose.yml file, making it easy to define complex applications with multiple components.
Docker Compose is a tool for defining and running multi-container Docker applications. It uses a YAML file to configure the application's services, networks, and volumes, allowing for easy management of complex applications.

Compose simplifies the control of your entire application stack, making it easy to manage services, networks, and volumes in a single, comprehensible YAML configuration file. Then, with a single command, you create and start all the services from your configuration file.

Compose works in all environments; production, staging, development, testing, as well as CI workflows. It also has commands for managing the whole lifecycle of your application:

1. Start, stop, and rebuild services
2. View the status of running services
3. Stream the log output of running services
4. Run a one-off command on a service

Helps in automating multi-container setups.


With Docker Compose you use a YAML configuration file, known as the Compose file, to configure your application’s services, and then you create and start all the services from your configuration with the Compose CLI.
The Compose file, or compose.yaml file, follows the rules provided by the Compose Specification in how to define multi-container applications.

`The Compose file`:- The default path for a Compose file is compose.yaml (preferred) or compose.yml that is placed in the working directory. Compose also supports docker-compose.yaml and docker-compose.yml for backwards compatibility of earlier versions. If both files exist, Compose prefers the canonical compose.yaml.

## Compose file reference

The Compose Specification is the latest and recommended version of the Compose file format. It helps you define a Compose file which is used to configure your Docker application’s services, networks, volumes, and more.

- **Version and name top-level elements**:- 

`Version top-level element (obsolete)`:- The top-level version property is defined by the Compose Specification for backward compatibility. It is only informative and you'll receive a warning message that it is obsolete if used.
Version - Docker compose version
Compose doesn't use version to select an exact schema to validate the Compose file, but prefers the most recent schema when it's implemented.

`Name top-level element`:- The top-level name property is defined by the Compose Specification as the project name to be used if you don't set one explicitly. Compose offers a way for you to override this name, and sets a default project name to be used if the top-level name element is not set.
Whenever a project name is defined by top-level name or by some custom mechanism, it is exposed for interpolation and environment variable resolution as COMPOSE_PROJECT_NAME

```yaml
version: "3.8"
name: myapp

services:
  foo:
    image: busybox
    command: echo "I'm running ${COMPOSE_PROJECT_NAME}"
```

- **Services top-level elements**:- A service is an abstract definition of a computing resource within an application which can be scaled or replaced independently from other components. Services are backed by a set of containers, run by the platform according to replication requirements and placement constraints. As services are backed by containers, they are defined by a Docker image and set of runtime arguments. All containers within a service are identically created with these arguments.
Services(Containers) - Ports published,Environment variables,Volumes and Networks.

A Compose file must declare a services top-level element as a map whose keys are string representations of service names, and whose values are service definitions. A service definition contains the configuration that is applied to each service container.
Each service may also include a build section, which defines how to create the Docker image for the service. Compose supports building Docker images using this service definition. If not used, the build section is ignored and the Compose file is still considered valid.

```yml
services:
  web:
    image: nginx:latest
    ports:
      - "8080:80"

  db:
    image: postgres:13
    environment:
      POSTGRES_USER: example
      POSTGRES_DB: exampledb
```

Attributes:-

- `build` specifies the build configuration for creating a container image from source.
- `container_name` is a string that specifies a custom container name, rather than a name generated by default.Compose does not scale a service beyond one container if the Compose file specifies a container_name. Attempting to do so results in an error.

```yml
container_name: my-web-container
```

- `depends_on`:- With the depends_on attribute, you can control the order of service startup and shutdown. It is useful if services are closely coupled, and the startup sequence impacts the application's functionality.

- `expose`:-  defines the (incoming) port or a range of ports that Compose exposes from the container. These ports must be accessible to linked services and should not be published to the host machine. Only the internal container ports can be specified.
Syntax is <portnum>/[<proto>] or <startport-endport>/[<proto>] for a port range. When not explicitly set, tcp protocol is used.

```yml
expose:
  - "3000"
  - "8000"
  - "8080-8085/tcp"
```


- **Networks top-level elements**:- Networks let services communicate with each other. By default Compose sets up a single network for your app. Each container for a service joins the default network and is both reachable by other containers on that network, and discoverable by the service's name. The top-level networks element lets you configure named networks that can be reused across multiple services.

To use a network across multiple services, you must explicitly grant each service access by using the networks attribute within the services top-level element. The networks top-level element has additional syntax that provides more granular control.

```yml
networks:
  frontend:
   # Specify driver options
   driver: bridge
   driver_opts:
      com.docker.network.bridge.host_binding_ipv4: "127.0.0.1"
```


- **Volumes top-level element**:- Volumes are persistent data stores implemented by the container engine. Compose offers a neutral way for services to mount volumes, and configuration parameters to allocate them to infrastructure. The top-level volumes declaration lets you configure named volumes that can be reused across multiple services.

To use a volume across multiple services, you must explicitly grant each service access by using the volumes attribute within the services top-level element. The volumes attribute has additional syntax that provides more granular control.

```yml
volumes:
  db-data:
```

```yaml
version: "3.8"
services:
   api:
      #build: ./api
      build:
         context: ./api
         dockerfile: Dockerfile-dev
         args:
      ports:
         - `80:80`
      volumes:
         - logs:/app/logs
         - ./api:/app # Bind mounts
         - /app/node_modules
      environments:
         MONGODB_USERNAME: username
         MONGODB_PASSWORD: password
      depends_on:
         - db

   ui:
      build: ./ui
      container_name: react-ui
      ports:
         - '3000:3000'
      volumes:
         - ./frontend/src:/app/src
      stdin_open: true
      tty: true
      depends_on:
         - api

   db:
      image: 'mongo'
      container_name: mongodb
      volumes:
         - data:/data/db
      environment:
         MONGO_INITRDB_ROOT_USERNAME: username
         MONGO_INITRDB_ROOT_PASSWORD: password

         - MONGO_INITRDB_ROOT_PASSWORD=password
      env_file:
         - ./env/mongo.env
      networks:
         - farmers_net
volumes:
   data:
   logs:
```

## CLI

The `Docker CLI` lets you interact with your Docker Compose applications through the docker compose command, and its subcommands. Using the CLI, you can manage the lifecycle of your multi-container applications defined in the compose.yaml file. The CLI commands enable you to start, stop, and configure your applications effortlessly.



```bash
# Check the version of Docker Compose installed
docker-compose --version

# Start the services defined in the Docker Compose file
docker-compose up

docker-compose up --build # Forces images to be rebuilt

# Start the services defined in the Docker Compose file in detached mode
docker-compose up -d

# Stop the services defined in the Docker Compose file
docker-compose down

# Stop the services defined in the Docker Compose file and removes the volume
docker-compose down -v

# Validate the Docker Compose file
docker-compose config

# List Docker images used by the services defined in the Docker Compose file
docker-compose images

# List the running services defined in the Docker Compose file
docker-compose ps

# Display the top resource-consuming processes of the services defined in the Docker Compose file
docker-compose top
```
